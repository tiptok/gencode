package api

const protocolx = "package protocol\n\nimport (\n\t\"encoding/json\"\n)\n\nconst (\n\tOk = iota\n\tServiceException\n\tInvalidArgs\n)\n\nvar (\n\terrorMap ErrorMap = map[int]string{\n\t\tOk:               \"成功\",\n\t\tServiceException: \"系统异常\",\n\t\tInvalidArgs:      \"参数错误\",\n\t}\n)\n\n//Message 解析自定义错误结构体\ntype (\n\tMessage interface {\n\t\tParseToMessage() *ResponseMessage\n\t}\n)\n\n//ErrorMap 统一消息错误编码\ntype (\n\tErrorMap map[int]string\n\t//BaseMessage 统一错误结构\n\tBaseMessage struct {\n\t\tCode int    `json:\"code\"`\n\t\tMsg  string `json:\"msg\"`\n\t}\n\n\t//ResponseMessage 统一返回消息结构体\n\tResponseMessage struct {\n\t\tBaseMessage\n\t\tData interface{} `json:\"data\"`\n\t}\n\n\t//ErrorMessage  自定义错误结构\n\tErrorMessage struct {\n\t\tErr error `json:\"-\"`\n\t\tBaseMessage\n\t}\n\n\t// RequestHeader 自定义请求头\n\tRequestHeader struct {\n\t\tUserId   int64 //UserId 唯一标识\n\t\tUserName string\n\t\tToken    string\n\t\tBodyKeys []string\n\t}\n)\n\n//Search 搜索错误描述\nfunc (m ErrorMap) Search(code int) BaseMessage {\n\tif v, ok := m[code]; ok {\n\t\treturn BaseMessage{\n\t\t\tCode: code,\n\t\t\tMsg:  v,\n\t\t}\n\t}\n\treturn BaseMessage{Code: code, Msg: \"错误码未定义\"}\n}\n\n// NewMessage\nfunc NewMessage(code int) *ResponseMessage {\n\treturn &ResponseMessage{\n\t\tBaseMessage: MatchMessage(code),\n\t\tData: struct {\n\t\t}{},\n\t}\n}\n\n//Error 实现接口error 中的方法\n//将BaseMessage转为json数据，建议用于日志记录\nfunc (e ErrorMessage) Error() string {\n\tbt, _ := json.Marshal(e.BaseMessage)\n\treturn string(bt)\n}\n\n//Unwrap 接口实现\nfunc (e ErrorMessage) Unwrap() error {\n\treturn e.Err\n}\n\n//ParseToMessage 实现Message的接口\nfunc (e ErrorMessage) ParseToMessage() *ResponseMessage {\n\treturn &ResponseMessage{\n\t\tBaseMessage: e.BaseMessage,\n\t\tData:    nil,\n\t}\n}\n\n// MatchMessage 根据code匹配消息\nfunc MatchMessage(code int) BaseMessage {\n\treturn errorMap.Search(code)\n}\n\n// NewResponseMessageData 新建一个应答数据 （根据应用层回来的数据应答）\nfunc NewResponseMessageData(data interface{}, err error) *ResponseMessage {\n\tvar msg *ResponseMessage\n\tif err == nil {\n\t\tmsg = NewMessage(0)\n\t\tmsg.Data = data\n\t\treturn msg\n\t}\n\t//log.Error(\"服务错误:\" + eRR.Error())\n\tif x, ok := err.(Message); ok {\n\t\tmsg = x.ParseToMessage()\n\t\tmsg.Data = data\n\t\treturn msg\n\t}\n\t//if v, ok := err.(*application.ServiceError); ok {\n\t//\tmsg = &ResponseMessage{\n\t//\t\tmessage{v.Code, v.Message},\n\t//\t\tdata,\n\t//\t}\n\t//\treturn msg\n\t//}\n\treturn NewMessage(ServiceException)\n}\n\n// NewResponseMessageListData 新建一个应答列表 （根据应用层回来的列表数据应答）\nfunc NewResponseMessageListData(data interface{}, err error) *ResponseMessage {\n\tmapData := map[string]interface{}{\"gridResult\": data}\n\treturn NewResponseMessageData(mapData, err)\n}\n\n// NewResponseMessage 新建一个应答（controller 直接应答）\nfunc NewResponseMessage(code int, err string) *ResponseMessage {\n\treturn &ResponseMessage{\n\t\tBaseMessage: BaseMessage{\n\t\t\tCode: code,\n\t\t\tMsg:  err,\n\t\t},\n\t\tData: struct {\n\t\t}{},\n\t}\n}\n\n// NewErrorMessage 错误消息 （application 抛错）\nfunc NewErrorMessage(code int, msg string) *ErrorMessage {\n\treturn &ErrorMessage{\n\t\tErr:     nil,\n\t\tBaseMessage: BaseMessage{code, msg},\n\t}\n}\n"
